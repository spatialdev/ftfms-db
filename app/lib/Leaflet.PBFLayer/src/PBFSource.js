var VectorTile = require('vector-tile').VectorTile;
var VectorTileFeature = require('vector-tile').VectorTileFeature;
var VectorTileLayer = require('vector-tile').VectorTileLayer;
var Protobuf = require('pbf');
var Point = require('point-geometry');

var Util = require('./PBFUtil');
var PBFFeature = require('./PBFFeature');
L.TileLayer.PBFLayer = require('./PBFLayer');
L.TileLayer.PBFPointLayer = require('./PBFPointLayer');


module.exports = L.TileLayer.PBFSource = L.TileLayer.Canvas.extend({

  options: {
    debug: false,
    url: "", //URL TO Vector Tile Source,
    clickableLayers: [], //which layers inside the vector tile should have click events?
    getIDForLayerFeature: function() {},
    tileSize: 256
  },
  layers: {}, //Keep a list of the layers contained in the PBFs
  processedTiles: {}, //Keep a list of tiles that have been processed already
  _eventHandlers: {},
  styleFor: function() {},


  initialize: function(options) {
    L.Util.setOptions(this, options);

    //a list of the layers contained in the PBFs
    this.layers = {};

    // tiles currently in the viewport
    this.activeTiles = {};

    // thats that have been loaded and drawn
    this.loadedTiles = {};

    this.styleFor = options.styleFor;

    this.layerLink = options.layerLink;

    this._eventHandlers = {};

    this._tilesToProcess = 0; //store the max number of tiles to be loaded.  Later, we can use this count to count down PBF loading.

  },

  onAdd: function(map) {
    var self = this;
    L.TileLayer.Canvas.prototype.onAdd.call(this, map);

//    determineActiveTiles(self, map);
//    map.on('moveend', function(evt) {
//      determineActiveTiles(self, map);
//    });

    if (typeof DynamicLabel === 'function' ) {
      this.dynamicLabel = new DynamicLabel(map, this, {});
    }

  },

  drawTile: function(canvas, tilePoint, zoom) {
    var ctx = {
      id: [zoom, tilePoint.x, tilePoint.y].join(":"),
      canvas: canvas,
      tile: tilePoint,
      zoom: zoom,
      tileSize: this.options.tileSize
    };

    //Capture the max number of the tiles to load here. this._tilesToProcess is an internal number we use to know when we've finished requesting PBFs.
    if(this._tilesToProcess < this._tilesToLoad) this._tilesToProcess = this._tilesToLoad;

    var id = ctx.id = Util.getContextID(ctx);
    this.activeTiles[id] = ctx;

    if(!this.processedTiles[ctx.zoom]) this.processedTiles[ctx.zoom] = {};

    if (this.options.debug) {
      this._drawDebugInfo(ctx);
    }
    this._draw(ctx);
  },

  setOpacity:function(opacity) {
    this._setVisibleLayersStyle('opacity',opacity);
  },

  setZIndex:function(zIndex) {
    this._setVisibleLayersStyle('zIndex',zIndex);
  },

  _setVisibleLayersStyle:function(style, value) {
    for(var key in this.layers) {
      this.layers[key]._tileContainer.style[style] = value;
    }
  },

  _drawDebugInfo: function(ctx) {
    var max = this.options.tileSize;
    var g = ctx.canvas.getContext('2d');
    g.strokeStyle = '#000000';
    g.fillStyle = '#FFFF00';
    g.strokeRect(0, 0, max, max);
    g.font = "12px Arial";
    g.fillRect(0, 0, 5, 5);
    g.fillRect(0, max - 5, 5, 5);
    g.fillRect(max - 5, 0, 5, 5);
    g.fillRect(max - 5, max - 5, 5, 5);
    g.fillRect(max / 2 - 5, max / 2 - 5, 10, 10);
    g.strokeText(ctx.zoom + ' ' + ctx.tile.x + ' ' + ctx.tile.y, max / 2 - 30, max / 2 - 10);
  },

  _draw: function(ctx) {
    var self = this;

    //This works to skip fetching and processing tiles if they've already been processed.
    var vectorTile = this.processedTiles[ctx.zoom][ctx.id];
    //if we've already parsed it, don't get it again.
    if(vectorTile){
      console.log("Skipping fetching " + ctx.id);
      self.parseVectorTile(parseVT(vectorTile), ctx, true);
      self.reduceTilesToProcessCount();
      return;
    }

    if (!this.options.url) return;
    var url = self.options.url.replace("{z}", ctx.zoom).replace("{x}", ctx.tile.x).replace("{y}", ctx.tile.y);

    var xhr = new XMLHttpRequest();
    xhr.onload = function() {
      if (xhr.status == "200") {

        if(!xhr.response) return;

        var arrayBuffer = new Uint8Array(xhr.response);
        var buf = new Protobuf(arrayBuffer);
        var vt = new VectorTile(buf);
        self.parseVectorTile(parseVT(vt), ctx);
        tileLoaded(self, ctx);
      }
      else {
        console.log("xhr.status = " + xhr.status);
      }
    };

    xhr.onerror = function() {
      console.log("xhr error: " + xhr.errorCode)
    }

    xhr.open('GET', url, true); //async is true
    xhr.responseType = 'arraybuffer';
    xhr.send();

    //either way, reduce the count of tilesToProcess tiles here
    self.reduceTilesToProcessCount();
  },

  reduceTilesToProcessCount: function(){
    this._tilesToProcess--;
    if(!this._tilesToProcess){
      //Trigger event letting us know that all PBFs have been loaded and processed (or 404'd).
      if(this._eventHandlers["PBFLoad"]) this._eventHandlers["PBFLoad"]();
    }
  },

  parseVectorTile: function(vt, ctx, parsed) {
    var self = this;

    for (var key in vt.layers) {
      var lyr = vt.layers[key];
      if (!self.layers[key]) {
        //Create PBFLayer or PBFPointLayer for user
        self.layers[key] = self.createPBFLayer(key, lyr.parsedFeatures[0].type || null);
      }

      //If layer is marked as visible, examine the contents.
      if (self.layers[key].visible === true) {
        if(parsed){
          //We've already parsed it.  Go get canvas and draw.
          self.layers[key].getCanvas(ctx, lyr);
        }else{
          self.layers[key].parseVectorTileLayer(lyr, ctx);

          //if we have a reasonable amount of features inside, lets store it in memory.  Otherwise, fetch every time to avoid memory pileup.
          if(lyr.parsedFeatures.length < 25){
            this.processedTiles[ctx.zoom][ctx.id] = vt;
          }
        }
      }
    }

    //Make sure manager layer is always in front
    this.bringToFront();
  },

  createPBFLayer: function(key, type) {
    var self = this;

    var getIDForLayerFeature;
    if (typeof self.options.getIDForLayerFeature === 'function') {
      getIDForLayerFeature = self.options.getIDForLayerFeature;
    } else {
      getIDForLayerFeature = Util.getIDForLayerFeature;
    }

    //Take the layer and create a new PBFLayer or PBFPointLayer if one doesn't exist.
    var layer;

//    if(type === 1){
//      //Point Layer
//      layer = new L.TileLayer.PBFPointLayer(self, {
//        getIDForLayerFeature: getIDForLayerFeature,
//        filter: self.options.filter,
//        layerOrdering: self.options.layerOrdering,
//        styleFor: self.styleFor,
//        name: key,
//        asynch: true
//      }).addTo(self._map);
//    }else{
      //Polygon/Line Layer
      layer = new L.TileLayer.PBFLayer(self, {
        getIDForLayerFeature: getIDForLayerFeature,
        filter: self.options.filter,
        layerOrdering: self.options.layerOrdering,
        styleFor: self.styleFor,
        name: key,
        asynch: true
      }).addTo(self._map);
    //}

    return layer;
  },

  getLayers: function() {
    return this.layers;
  },

  hideLayer: function(id) {
    if (this.layers[id]) {
      this._map.removeLayer(this.layers[id]);
      this.layers[id].visible = false;
    }
  },

  showLayer: function(id) {
    if (this.layers[id]) {
      this.layers[id].visible = true;
      this._map.addLayer(this.layers[id]);
    }
    //Make sure manager layer is always in front
    this.bringToFront();
  },

  removeChildLayers: function(map){
    //Remove child layers of this group layer
    for (var key in this.layers) {
      var layer = this.layers[key];
      map.removeLayer(layer);
    }
  },

  bind: function(eventType, callback) {
    this._eventHandlers[eventType] = callback;
  },

  onClick: function(evt, cb) {
    //Here, pass the event on to the child PBFLayer and have it do the hit test and handle the result.
    var self = this;

    evt.tileID =  getTileURL(evt.latlng.lat, evt.latlng.lng, this._map.getZoom());

    //If no layer is specified as clickable, just use the 1st one.
    if(this.options.clickableLayers.length == 0) {
      var names = Object.keys(self.layers);
      self.layers[names[0]].handleClickEvent(evt, function (evt) {
        cb(evt);
      });
    }
    else{
      for (var key in this.layers) {
        var layer = this.layers[key];
        if(self.options.clickableLayers.indexOf(key) > -1){
          layer.handleClickEvent(evt, function(evt) {
            cb(evt);
          });
        }
      }
    }
  }
});


if (typeof(Number.prototype.toRad) === "undefined") {
  Number.prototype.toRad = function() {
    return this * Math.PI / 180;
  }
}

function getTileURL(lat, lon, zoom) {
  var xtile = parseInt(Math.floor( (lon + 180) / 360 * (1<<zoom) ));
  var ytile = parseInt(Math.floor( (1 - Math.log(Math.tan(lat.toRad()) + 1 / Math.cos(lat.toRad())) / Math.PI) / 2 * (1<<zoom) ));
  return "" + zoom + ":" + xtile + ":" + ytile;
}

function tileLoaded(pbfSource, ctx) {
  pbfSource.loadedTiles[ctx.id] = ctx;
}

function parseVT(vt){
  for (var key in vt.layers) {
    var lyr = vt.layers[key];
    parseVTFeatures(lyr);
  }
  return vt;
}

function parseVTFeatures(vtl){
  vtl.parsedFeatures = [];
  var features = vtl._features;
  for (var i = 0, len = features.length; i < len; i++) {
    var vtf = vtl.feature(i);
    vtf.coordinates = vtf.loadGeometry();
    vtl.parsedFeatures.push(vtf);
  }
  return vtl;
}
